start in 2012.2.7 end in 2012.2.29
------------------------PHP---start------------------------
(PHP简明教程.doc)
语法：
<?php......?>
<?......?>
require("file.php");//通常放在最前面，执行前读入
include("file.php");//一般放在流程控制的处理部分中，执行到时读入
<?php
	echo "string;\n";//注释内容
	/*注释内容*/
	echo "string;\n";#注释内容
?>
$str = "string";
$line = "string\n";
$int1 = 38;
$float1 = 1.732;
$float2 = 1.4#+2;
$array1 = array("1", "2", "a", "b", "c");
+、-、*、/、%、++、--
$a = "aaa";
$b = "bbb";
echo $a.$b;//"."号连接字符串
<、>、<=、>=、==、!=、&&、and、||、or、xor、!
if(expr){statement}//单行可省略大括号
if(expr){statement}else{statement};
if..else if...else...
for(expr1; expr2; expr3){statement};
switch(expr){case expr1:statement1;break; case......;default:statementN;break;}
$obj->username;
$_POST['html_id'];//提取POST过来的数据
$_GET['html_id'];//提取GET过来的数据
数据库：
mysql_connect(string[hostname][:port], string[username], string[password]);
mysql_select_db(string[database_name], int[link_identifier]);
mysql_query(string[query], int[link_identifier]);
mysql_fetch_object(int[result], int[result_typ]);//遍历查询结果
SESSION：
session_start();//开启SESSION
$_SESSION['item'] = "item1";
$item1 = $_SESSION['item'];
empty($_SESSION['inum']);//inum是否为空
echo "<script>alert('Password Check Error!');location.href='login.php';</script>";
ceil($num/10));
<a href="xxx.php?page=<?=($page-1)?>">PrevPage</a>
<a href="xxx.php?page=<?=ceil($num/10)-1?>">LastPage</a>
上传文件和发送邮件：
表单必须加上enctype="multipart/form-data"和<input type="file" name="file">
$f = & $HTTP_POST_FILES['file'];
$dest_dir = 'uploads';//设定上传目录
$dest = $dest_dir.'/'.date("ymd")."_".$f['name'];//设置文件名为日期加上文件名避免重复
$r = move_uploaded_file($f['tmp_name'], $dest);//这个函数是关键
chmod($dest, 0755);//设定上传的文件的属性
mail("收件人地址", "主题", "正文", "From:发件人\r\nReply-to:发件人的地址");
------------------------PHP----end-------------------------
------------------------Drupal 7 Module---start------------------------
一、介绍
使用procedural programming(过程式编程)方式开发
Drupal modules由函数集组成
Drupal core libraries
Drupal hooks
Drupal core modules
The Database
The theme system
Drupal's major subsystems
(Theme,Menus(树状结构),Nodes(类似文本结构),Files,Users,Comments,
Fields and entities,Forms API,Installation Profiles,
Simple test,Blocks,Other subsystems)
二、简单模块
一个module有两个名字：human-readable name和machine-readable name
名字的大写会转换成小写
/modules目录只给核心Drupal模块保留，每次更新会被重写
/sites/all/modules目录全是未更改模块，除非运行多站点配置并且自定义模块需要访问所有站点
/sites/default/modules或者/sites/all/modules/custom目录通常存放自定义模块
目录名称为machine-readable name，.info和.module文件也要以machine-readable name为文件名
.info文件提供此模块的human-readable name信息，需要依赖哪些modules，此modules有哪些代码文件等
.info格式：
;$Id$
name = first
description = A first module.
package = Drupal 7 Development
core = 7.x
files[] = first.module
;dependencies[] = autoload
;php = 5.2
1.如果value占用超过一行，应该用引号标记
2.";"开头的行会被视为注释而被Drupal INI忽略
3.第一行是标准，每个.info文件都应该以";$Id$"开头。它是版本控制系统存储此文件的信息的占位符
4.name和description是必须指定的，name定义human-raedable name，description定义此模块的描述
5.package标识这个module与哪些modules有关
6.core
7.files[]，每个.info文件必须公布模块里哪些文件包含了PHP的函数、类、接口
.module格式：
1.".module"文件通常包含这个模块的所有主要的钩子实现
2.当Drupal遇到含有hook的事件，Drupal将会遍历、执行所有modules寻找匹配的hook实现
3.以"<?php"开头，可省略"?>"
4.每个module都可以有一个hook_help()实现
5.hook_help()参数$path是帮助系统的URI路径，$arg是访问此URI的参数
6.t('string')负责转换一种语言的字符到其他语言，不能t($var)调用[P41]
7.hook_block_info()告诉Drupal添加新block[声明block]
8.hook_blick_view()告诉Drupal新block请求显示时要做些什么[显示block]
9.每个module只能够实现提供一个hook一次，只能有一个first_block_info()
10.当module需要创建多个block，必须使一个block实现管理多个block的功能
11.hook_block_info()不需要入参，返回array。
12.info提供此block的一句话描述，cache告诉Drupal此block怎样缓存数据
13.hook_block_view(block名字检索)，返回此检索的数组数据
14.theme(theme_operation_name, theme_operation_associative_variables_array)
15.module_invoke(module_name, hook_name)调用给一个特定的module下一个特定的钩子
三、主题层
1.presentation logic显示逻辑
2.如果主题提供了自己的实现，Drupal将会替换调module的主题
3.PHPTemplate theme engine
4.实现主题钩子方式：a.Theme functions;b.Templates
5.theme_THEME_HOOK_NAME($variables)，入参是想在函数里使用的数据组成的数组
6.MODULE_preprocess_THEME_HOOK_NAME(&$variables)，不返回数据
7.template_preprocess_THEME_HOOK_NAME(&$variables)
  拥有主题钩子参数的预处理权限，且应该在其他moddule预处理函数前执行
8.MODULE_preprocess(&$variables, $hook)，template函数和多个钩子的预加载函数
  hook包含正在运行的主题钩子的名字
9.过程函数在预初始化函数之后执行
10.过程函数：template-prefixed process functions, multi-hook process functions,
   module-provided process functions, theme-provided process functions
11.过程函数在所有预处理函数运行完毕之后运行
12.Drupal7在template_process_html()函数运行前生成CSS和js文件列表
13.所有预处理函数都比所有过程函数先运行
14.template_prefixed函数首先运行，MODULE_prefixed函数第二位运行，THEME_prefixed函数最后运行
15.Multi-hook函数在hook-specific函数前运行
16.执行一个特定主题的钩子所遵循的执行流程：
	template_preprocess()
	template_preprocess_HOOK()
	MODULE_preprocess()
	MODULE_preprocess_HOOK()
	THEME_preprocess()
	THEME_preprocess_HOOK()
	template_process()
	template_process_HOOK()
	MODULE_process()
	MODULE_process_HOOK()
	THEME_process()
	THEME_process_HOOK()
17.Render element是一个复杂数据结构，通过传递一个单独的参数[arrays]给theme()
18.着色元素数组包含：需要着色的数据，此元素下面的其他着色元素，
   在应用此数据时能够用上的主题钩子，应用主题前后将要调用的回调函数列表
19.着色元素内部用drupal_render()输出[$output .= drupal_render($element);]
20.$element格式：
   属性以"#"开头，子元素不以"#"开头，值会在发送到具体主题实现前于theme()里替换调"#"
21.Render properties有两个定义的地方：
   第一个地方是直接在drupal_render()和它的帮助函数里定义[drupal_render()使用的属性列表P79]
   第二个地方是在hook_element_info()里定义
22.每个#type元素都必须在hook_element_info()的实现里定义
23.使用system_element_info()的框架，modules能够通过实现hook_element_info()
   去创建各自的复杂着色元素，并且创建任何回调和关联API
24.opportunities延迟
25.hook_page_alter()的两个有用的例子是：
   允许插入一个block到页面的主内容，或者在页面范围内翻转、移动"Field"到某个地点
四、模块样式
1.theme_item_list()，期望作为一个item数组参数
2.构建默认主题步骤：
	a.注册主题钩子，并定义默认参数
	b.构建主题钩子的默认实现
	c.重构注册主题
	d.构建用于主题钩子的着色元素
3.$classes变量被template_processs()创建，与它相当的$classes_array被template_preprocess()创建
4.如果我们需要添加classes到$classes，添加一个数组元素到$classes_array就可以
五、Admin接口
1.using hook_menu() to mapping Drupal functions to menu items
2.用variable_set()和variable_get()管理Drupal的设置
3.用drupal_mail()和hook_mail()发送邮件
4.如果访问的页面不存在，Drupal将会跳转到上级地址（逐层跳转知道该地址存在）
5.Permissions are defined by modules using hook_permission()
6.查找访问权限信息的唯一途径是通过检查hook_perm()的实现
7.Form API, Field API, File API
8.Form API在Drupal安全性里是一个重要的元素
9.drupal_get_form()需要传递一个form ID，可以是任意值，但是在Drupal必须是唯一的，
  典型的命名方式是<module_name>_<description>_form
10.http://www.v2ex.com/rework
11.'#type' => 'value'时传递的value可以是任意数据结构，value元素不包含进返回的HTML代码
12.Persistent variables are saved using variable_set()set(), and retrieved usingvariable_get()
13.http://v.youku.com/v_show/id_XMzM1NDc1ODc2.html
14.system_settings_form()
15.发送邮件流程
   a.调用drupal_mail()
   b.Drupal根据drupal_mail()头信息创建邮件信息
   c.drupal_mail()里调用hook_mail()的实现，添加了邮件内容
   d.邮件的所有组成都发送到hook_mail_alter()，允许其他modules修改
   e.邮件传送到durpal_send_mail()
   f.*通常只需要实现druapl_mail()和hook_mail()
16.Drupal's token system,格式如"[site:name]"也可如"[node:author:e-mail]",token_replace()会自动替换
六、Content
1.相对于创建单独node类型，更有必要创建entities的情况:
  a.我们需要entities拥有相对于nodes完全不同的权限控制或者工作流
  b.我们需要访问entities且不存储到本地数据库，譬如传统的数据存储
  c.我们需要拥有内部变量，像node类型，但是nodes不支持子类型
2.旧版本只有nodes支持sub-types，7以后版本所有entities都支持，Drupal里的sub-types称为bundles
3.bundle是entity里可单独配置的sub-type，Node类型是bundle的一个例子
4.不是所有的entity类型都有bundle，如Users就没有独立的bundle
5.真实的用例中通常允许包含一个Administration系统，以创建、管理bundles
6.用Schema API（Drupal数据层的一部分，不依赖数据库的API）创建数据表
7.hook_schema()是".install"文件最重要的钩子，定义该module提供哪些数据表
8.A "controller" is an object that handles the loading of the entity object for us
9.static cache表示controller需要在内存中保存一份entity副本
10.fieldable表示可以通过Field API给entity和node附加字段，是可定义新entity类型的主要原因之一
11.所有Drupal路径使用连接符代替下划线，但bundle名字必须使用下划线
12.drupal_static()函数，担当PHP静态变量的中心集合
13.当系统某个部分没有独立的$reset参数时，系统强制重置静态缓存
14.当一些代码尝试创建Controller的新实例时，Controller将会懒加载*.inc文件，使class可使用
15.check_plain()，过滤不信任的字符
16.menu_get_item()返回当前菜单条目，system_admin_menu_block()，通过任意菜单条目获取对应子菜单
17.transactions不支持MySQL和MyISAM数据表
七、Field
1.Field API组成
	Field type:field名字和数据结构(不是如何保存、如何显示)
	Field:field类型的详细配置
	Field instance:说明一个特殊的field的组成是一个bundle还是entity类型的子类
	Widget:给内容编辑器的一个表格元素
	Formatter:格式化field样式的代码段，将覆盖Drupal主题系统
2.尽管不是绝对需要(大多数field将会通过drupal的网络接口配置)，还是可给field设置提供一个配置表
3."One" is simply a special case of "many".
4.validate钩子里（扩展至Drupal的大多数情况下），field作为数组的item传送，而不是单独的item
5.widget是简单的Form API片段，扩展Form组件，能够构建成一个大表格，
6.widget的典型用途是构建一个不需要保存field类型本身，只需要保存field值的组件
7.创建的表格元素与dimensions field栏的名字相同
8.explode()函数，根据第一个参数分割字符串，组合成数组；list()将会分割此数组
9.用form_set_value()设置表格元素的值
10.$form_state集合与field的栏目相匹配
11.formatter有两个回调，大多数只用其中一个。
   [module]_field_formatter_view()和[module]_table()
   [module]_field_formatter_settings_form()和[module]_field_formatter_settings_summary()
12.Apache Solr
13.用一个名字为EntityFieldQuery的类为entities和fileds提供一个查询构造器
   three "levels" of data can filter:
   a.Entity level data,所有entites的所有类型的数据，包含entity类型,bundle名字,entityID,revisionID
   b.Properties,根据提供的一个entity类型查询所有Object的数据元素，但不是所有entity
   c.Fields,针对提供的一个bundle定义，可能也会被entity共享不同的类型
14.entityOrderBy(),propertyCondition(),fieldOrderBy()
15.widget能与URL或者第三方数据交互，处理默认值，或者根据某些条件显示表格field的不同点
16.formatter能使用主题系统以显示数据本身或者影响JS库去创建可视化交互式的field数据
八、权限和安全
1.权限处于Drupal安全范围内。
2.user_access(string, account),权限的机器名称,$user对象的副本[user_load()返回]
3.hook_permission()返回此模块的所有必须的权限信息
4.drupal_exit()终止页面继续加载其余部分，不要直接使用PHP的exit(),可能会终止内部函数或者钩子
5.可以用MENU_ACCESS_DENIED代替drupal_exit()
6.页面层的访问检查：
  如果把访问检查放到菜单回调，当检查通过，tab链接将只被渲染，通常做法
  如果把访问检查放到页面回调，无论是否通过，tab链接都会被渲染，体验不好
  drupal_access_denied()返回服务器的403页面，设置面板可指定自定义的403、404页面
8.在模块的install文件里实现hook_enable()，能用代码的方式定义权限，函数内容如：
  $permissions = array('view page');
  //如果是设置数组，则
  $permissions = array(
	'view page' => TRUE,
	'access content' => FALSE;
  );
  user_role_change_permissions(DRUPAL_AUTHENTICATED_USER,$permissions);
9.和上条相对应的，也可以实现hook_disable()，用user_role_revoke_permissions()设置拒绝权限
10.user_role_save()和user_role_delete()函数能设置模块的角色[role]
11.user_rolr_load_by_name(),user_role_grant_permissions()
12.当Drupal通过Form API生成表格时，会添加一个用md5哈希生成的form_build_id的token去鉴定
   在drupal_build_form()里实现这个id
13.user_access()
   $form['menu'] = array(
	'#type' => 'fieldset',
	'#title' => t('Menu settings'),
	'#access' => user_access('administer menu'),//在Form API里，此属性和#disabled不同
	'#collapsible' => TRUE,
	'#collapsed' => !$link['link_title'],
   );
14.传送HTML的隐藏元素，表格属性'#type' => 'value'
15.Using AJAX in other contexts木有细看
九、节点接入
1.Node Access系统提供一个决定授权、权限的API，
2.node的基本操作：CRUD(Create,Read,Update,Delete)
3.（控制node访问安全）Node访问权限记录两个实例：
  什么时候的请求对创建个体node起作用（通常由菜单回调和node_access()函数处理）
  什么时候的数据库查询返回符合条件的node列表
4.数据库查询中的query:->addTag('node_access')指令调用node_query_node_access_alter()函数，
  此函数当查询发送到数据库时，应用'允许node访问规则'，
  不需要那么多查看、编辑、删除等授权，忽略站点的权限定义
5.node_access(op,node,account)是node操作的主要访问回调，
  在node_menu()定义，作为创建查看编辑删除node的访问回调
  op表明Node操作被请求，node参数用在创建Node的情况，
  在整个页面请求过程中，静态存储每个用户的访问权限
6.[module]_node_access()和[module]_node_grants()
7.无论什么时候，写访问检查时，FALSE都是默认返回值
8.P251的Create、Update、Delete操作Demo
9.node_access表用node id(nid)作为主键，只用来检查已发布的文章的访问权限
10.只实现hook_node_access()的module不在node_access表添加记录，也不添加查询变更逻辑
11.NODE_ACCESS_ALLOW,NODE_ACCESS_DENY,NODE_ACCESS_IGNORE
12.只有Node访问Module才能通过视图操作维护规则，访问控制Module能克制这么做
13.access control module和node access module
14.hook_node_access()只对运行个人Node的访问检查有效
15.hook_node_access()能否决由其他Module定义的行为，可能不太令人满意
16.hook_node_access()推荐给单用例module，尤其是为特殊site或者project的Module
17.Node access module能与其他module协作，提供灵活的访问控制规则
   一个Module的Node access rules可能被其他Module修改，hook_node_access()无法实现
   Node access module代表通常的使用场景地址，且能被更多people复用
18.access control module和node access module的主要区别是使用node_access表
   当node access module已经安装，数据库会把node表添加到node_access表以达到划清返回值的列表的目的
19.node_access表包含一个单独的记录，这允许所有内容都能显示给所有用户
20.当所有node access module激活，这个默认记录会被删除，node查询将会作适当修改
21.P264，node_access表各字段含义(每条记录定义node的规则设定，此表不关心node的发布状态)
22.role_access_node_grants($account, $op)
23.However, if your module relies on data not stored by Drupal core or
   contributed modules – both of which should be listed as dependencies[] in your
   module.info file – then it is your responsibility to store the data necessary to rebuild
   the {node_access} table properly.
24.Domain Access module
25.hook_node_load()
26.hook_node_access_records_alter()和hook_node_grants_alter()
27.Devel Node Access module
十、JavaScript
1.notepad++去掉文件历史的config.xml文件设置项History nbMaxFile="0"
十一、文件和图像
十二、安装配置文件
附录A、数据库访问
附录B、安全
------------------------Drupal 7 Module----end-------------------------
------------------------PHP---start------------------------
------------------------PHP----end-------------------------
